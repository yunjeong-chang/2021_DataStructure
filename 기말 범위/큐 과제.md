**1번. 두 개의 스택으로 구성된 큐를 구현한 프로그램**
```c
#include <stdio.h>
#include <stdlib.h>

void push(char* stack, int* top, char data) {
	if (*top >= 100 - 1) {
		printf("Stack FULL\n");
		return;
	}
	(*top)++;
	stack[*top] = data;
	return;
}

char pop(char* stack, int* top) {
	if (*top <= -1) {
		printf("empty queue\n");
		return 0;
	}
	(*top)--;
	return stack[*top + 1];
}

char dequeue(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
	}
	printf("%c\n", pop(stack2, top2));
}

void front_print(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
	}
	printf("%c\n", stack2[*top2]);
}

int main() {
	char* stack1 = (char*)malloc(100 * sizeof(char));
	int top1 = -1;
	char* stack2 = (char*)malloc(100 * sizeof(char));
	int top2 = -1;

	int n, i;
	scanf("%d", &n); //연산의 개수 입력
	getchar();

	for (i = 0; i < n; i++) {
		char ch;
		scanf("%c", &ch);
		getchar();

		if (ch == 'E') { //enqueue : 큐에 원소 s 삽입
			char elem;
			scanf("%c", &elem);
			getchar();
			push(stack1, &top1, elem);
		}
		if (ch == 'D') { //dequeue : 큐에서 원소를 삭제한 후 출력
			dequeue(stack1, &top1, stack2, &top2);
		}
		if (ch == 'F') { //front_print : 큐의 front 원소를 삭제하지 않고 출력만
			front_print(stack1, &top1, stack2, &top2);
		}

	}
	return 0;
}
```

---

**2번. 문제 1에서 구현한 큐를 기반으로 아래와 같은 연산을 추가로 구현**
```c
#include <stdio.h>
#include <stdlib.h>

void push(char* stack, int* top, char data) {
	if (*top >= 100 - 1) {
		printf("Stack FULL\n");
		return;
	}
	(*top)++;
	stack[*top] = data;
	return;
}

char pop(char* stack, int* top) {
	if (*top <= -1) {
		printf("empty queue\n");
		return 0;
	}
	(*top)--;
	return stack[*top + 1];
}

char dequeue(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
		printf("%c\n", pop(stack2, top2));
	}
	else {
		printf("%c\n", pop(stack2, top2));
	}
}

void front_print(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
	}
	printf("%c\n", stack2[*top2]);
}

void print(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
	}
	for (int i = *top2; i >= 0; i--)
		printf("%c", stack2[i]);
	printf("\n");
}

void dequeueAll(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
		for (int i = *top2; i >= 0; i--)
			printf("%c", pop(stack2, top2));
		printf("\n");
	}
	else {
		for (int i = *top2; i >= 0; i--)
			printf("%c", pop(stack2, top2));
		printf("\n");
	}
}

int main() {
	char* stack1 = (char*)malloc(100 * sizeof(char));
	int top1 = -1;
	char* stack2 = (char*)malloc(100 * sizeof(char));
	int top2 = -1;

	int n, i;
	scanf("%d", &n); //연산의 개수 입력
	getchar();

	for (i = 0; i < n; i++) {
		char ch;
		scanf("%c", &ch);
		getchar();

		if (ch == 'E') { //enqueue : 큐에 원소 s 삽입
			char elem;
			scanf("%c", &elem);
			getchar();

			if (top1 == -1) {
				if (top2 != -1) { //s1 비어있는데 s2 안비어있으면
					while (top2 != -1) {
						push(stack1, &top1, pop(stack2, &top2));
					}
				}
			}
			push(stack1, &top1, elem);
		}
		if (ch == 'D') { //dequeue : 큐에서 원소를 삭제한 후 출력
			dequeue(stack1, &top1, stack2 , &top2);
		}
		if (ch == 'F') { //front_print : 큐의 front 원소를 삭제하지 않고 출력만
			front_print(stack1, &top1, stack2, &top2);
		}
		if (ch == 'P') {  //Print : 큐의 모든 원소 출력
			print(stack1, &top1, stack2, &top2);
		}
		if (ch == 'A') {  //dequeueAll 
			dequeueAll(stack1, &top1, stack2, &top2);
		}
	}
	return 0;
}
```


**<두개의 큐로 스택 구현하기 (정확한지는 모르겠다..ㅎ)>**
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
	int front; //프런트
	int rear;  //리어
	int* que;  //큐의 맨 앞 요소에 대한 포인터
	int num;   //현재의 요소 개수
	int max;   //큐의 최대 용량
} Queue;

int Initialize(Queue* q, int max) { //큐 초기화
	q->que = (int*)malloc(max * sizeof(int));

	for (int i = 0; i < max; i++) {
		q->que[i] = 0;
	}
	q->max = max;
	q->num = max;
	q->front = 0;
	q->rear = 0;
	return 0;
}

int IsEmpty(Queue* q) { //큐가 비어있는가?
	return (q->front == q->rear % q->num);
}

int IsFull(Queue* q) { //큐가 가득 찼는가?
	return (q->front == (q->rear + 1) % q->num);
}

void Print(Queue* q) { //모든 데이터 출력
	for (int i = 0; i < q->num; i++)
		printf("%c", q->que[i]);
}

int Enque(Queue* q, int x) { //큐에 데이터를 인큐
	if (IsFull(q)) {
		printf("overflow");
		Print(q);
		return -1;
	}
	else {
		q->rear = (q->rear + 1) % (q->num);
		q->que[q->rear] = x;
		return 0;
	}
}

int Deque(Queue* q) { //큐에서 원소를 삭제한 후 해당 배열 원소 값을 0으로 치환
	if (IsEmpty(q)) {
		printf("underflow");
		return -1;
	}
	else {
		q->front = (q->front + 1) % (q->num);
		int tmp = q->que[q->front];
		q->que[q->front] = 0;
		return tmp;
	}
}

void Terminate(Queue* q) { //큐 종료
	if (q->que != NULL)
		free(q->que);
	q->max = q->num = q->front = q->rear = 0;
}

void push(Queue* q1, Queue* q2, char data) {
	if (IsEmpty(q1)) {
		Enque(q1, data);
	}
	else {
		while (!IsEmpty(q1)) {
			Enque(q2, Deque(q1));
		}
		Enque(q1, data);
		while (!IsEmpty(q2)) {
			Enque(q1, Deque(q2));
		}
	}
}

char pop(Queue* q1, Queue* q2) {
	if (IsEmpty(q1)) {
		printf("underflow");
		return -1;
	}
	else {
		while (!(IsEmpty(q1) + 1)) {
			Enque(q2, Deque(q1));
		}
		Deque(q1);
		while (!IsEmpty(q2)) {
			Enque(q1, Deque(q2));
		}
	}
}

int main() {
	int q;
	scanf("%d", &q); //원형 큐의 크기 입력

	Queue Que1, Que2;
	Initialize(&Que1, q); //큐 초기화
	Initialize(&Que2, q); //큐 초기화

	int cnt;
	char str[6], data;
	scanf("%d", &cnt);
	for (int i = 0; i < cnt; i++) {
		scanf("%s", str);

		if (strcmp(str, "PUSH") == 0) {
			scanf(" %c", &data);
			push(&Que1, &Que2, data);
		}
		else if (strcmp(str, "POP") == 0)
			pop(&Que1, &Que2);

		else if (strcmp(str, "PRINT") == 0) {
			Print(&Que1);
			printf("\n");
		}
	}
	return 0;
}
```
