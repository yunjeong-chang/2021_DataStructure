**1번. 두 개의 스택으로 구성된 큐를 구현한 프로그램**
```c
#include <stdio.h>
#include <stdlib.h>

void push(char* stack, int* top, char data) {
	if (*top >= 100 - 1) {
		printf("Stack FULL\n");
		return;
	}
	(*top)++;
	stack[*top] = data;
	return;
}

char pop(char* stack, int* top) {
	if (*top <= -1) {
		printf("empty queue\n");
		return 0;
	}
	(*top)--;
	return stack[*top + 1];
}

char dequeue(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
	}
	printf("%c\n", pop(stack2, top2));
}

void front_print(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
	}
	printf("%c\n", stack2[*top2]);
}

int main() {
	char* stack1 = (char*)malloc(100 * sizeof(char));
	int top1 = -1;
	char* stack2 = (char*)malloc(100 * sizeof(char));
	int top2 = -1;

	int n, i;
	scanf("%d", &n); //연산의 개수 입력
	getchar();

	for (i = 0; i < n; i++) {
		char ch;
		scanf("%c", &ch);
		getchar();

		if (ch == 'E') { //enqueue : 큐에 원소 s 삽입
			char elem;
			scanf("%c", &elem);
			getchar();
			push(stack1, &top1, elem);
		}
		if (ch == 'D') { //dequeue : 큐에서 원소를 삭제한 후 출력
			dequeue(stack1, &top1, stack2, &top2);
		}
		if (ch == 'F') { //front_print : 큐의 front 원소를 삭제하지 않고 출력만
			front_print(stack1, &top1, stack2, &top2);
		}

	}
	return 0;
}
```

---

**2번. 문제 1에서 구현한 큐를 기반으로 아래와 같은 연산을 추가로 구현**
```c
#include <stdio.h>
#include <stdlib.h>

void push(char* stack, int* top, char data) {
	if (*top >= 100 - 1) {
		printf("Stack FULL\n");
		return;
	}
	(*top)++;
	stack[*top] = data;
	return;
}

char pop(char* stack, int* top) {
	if (*top <= -1) {
		printf("empty queue\n");
		return 0;
	}
	(*top)--;
	return stack[*top + 1];
}

char dequeue(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
		printf("%c\n", pop(stack2, top2));
	}
	else {
		printf("%c\n", pop(stack2, top2));
	}
}

void front_print(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
	}
	printf("%c\n", stack2[*top2]);
}

void print(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
	}
	for (int i = *top2; i >= 0; i--)
		printf("%c", stack2[i]);
	printf("\n");
}

void dequeueAll(char* stack1, int* top1, char* stack2, int* top2) {
	if (*top2 == -1) {
		if (*top1 == -1) {
			printf("empty queue\n");
			return 0;
		}
		while (*top1 != -1) {
			push(stack2, top2, pop(stack1, top1));
		}
		for (int i = *top2; i >= 0; i--)
			printf("%c", pop(stack2, top2));
		printf("\n");
	}
	else {
		for (int i = *top2; i >= 0; i--)
			printf("%c", pop(stack2, top2));
		printf("\n");
	}
}

int main() {
	char* stack1 = (char*)malloc(100 * sizeof(char));
	int top1 = -1;
	char* stack2 = (char*)malloc(100 * sizeof(char));
	int top2 = -1;

	int n, i;
	scanf("%d", &n); //연산의 개수 입력
	getchar();

	for (i = 0; i < n; i++) {
		char ch;
		scanf("%c", &ch);
		getchar();

		if (ch == 'E') { //enqueue : 큐에 원소 s 삽입
			char elem;
			scanf("%c", &elem);
			getchar();

			if (top1 == -1) {
				if (top2 != -1) { //s1 비어있는데 s2 안비어있으면
					while (top2 != -1) {
						push(stack1, &top1, pop(stack2, &top2));
					}
				}
			}
			push(stack1, &top1, elem);
		}
		if (ch == 'D') { //dequeue : 큐에서 원소를 삭제한 후 출력
			dequeue(stack1, &top1, stack2 , &top2);
		}
		if (ch == 'F') { //front_print : 큐의 front 원소를 삭제하지 않고 출력만
			front_print(stack1, &top1, stack2, &top2);
		}
		if (ch == 'P') {  //Print : 큐의 모든 원소 출력
			print(stack1, &top1, stack2, &top2);
		}
		if (ch == 'A') {  //dequeueAll 
			dequeueAll(stack1, &top1, stack2, &top2);
		}
	}
	return 0;
}
```
