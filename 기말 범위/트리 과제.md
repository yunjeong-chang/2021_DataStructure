**1번. 트리 정보와 순회 정보가 주어졌을 때, 트리를 생성하고 주어진 순회 방법과 노드 번호가 주어지면 해당 노드를 시작점으로 순회하며 노드의 문자열 값을 출력하는 프로그램**
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef struct node {
	struct node* left;
	struct node* right;
	int id;
	char data;
}Node;

Node* getNode(int id) {
	Node* new = (Node*)malloc(sizeof(Node));
	new->left = NULL;
	new->right = NULL;
	new->id = id;
	return new;
}

Node* searchNode(Node* root, int id) {
	if (root->id == id) {
		return root;
	}
	else {
		if (root->left != NULL) {
			Node* Left = searchNode(root->left, id);
			if (Left != NULL) {
				return Left;
			}
		}
		if (root->right != NULL)
			return searchNode(root->right, id);
	}
	return NULL;
}

void addNode(Node* root, int nodeID, int nodeLeft, int nodeRight, char nodeData) {
	if (root == NULL) return;

	Node* leftchild = getNode(nodeLeft);
	Node* rightchild = getNode(nodeRight);

	if (root->id == nodeID) {
		root->data = nodeData;
		if (nodeLeft == 0) {
			root->left = NULL;
			free(leftchild);
		}
		else {
			root->left = leftchild;
		}
		if (nodeRight == 0) {
			root->right = NULL;
			free(rightchild);
		}
		else {
			root->right = rightchild;
		}
	}
	else {
		free(leftchild);
		free(rightchild);
	}
	addNode(root->left, nodeID, nodeLeft, nodeRight, nodeData);
	addNode(root->right, nodeID, nodeLeft, nodeRight, nodeData);
}

void preorder(Node* root) { //선위순회
	if (root != NULL) {
		printf("%c", root->data);
		preorder(root->left);
		preorder(root->right);
	}
}

void inorder(Node* root) { //중위순회
	if (root != NULL) {
		inorder(root->left);
		printf("%c", root->data);
		inorder(root->right);
	}
}

void postorder(Node* root) { //후위순회
	if (root != NULL) {
		postorder(root->left);
		postorder(root->right);
		printf("%c", root->data);
	}
}

void orderTree(Node* root, int order, int node_id) {
	if (root == NULL) return;

	if (root->id == node_id) {
		if (order == 1) {
			preorder(root);
		}
		else if (order == 2) {
			inorder(root);
		}
		else if (order == 3) {
			postorder(root);
		}
	}
	else {
		orderTree(root->left, order, node_id);
		orderTree(root->right, order, node_id);
	}
}

int main() {
	int n, i, nodeID, nodeLeft, nodeRight;
	char nodeData;
	Node* root, * tree = (Node*)malloc(sizeof(Node));
	root = tree;
	scanf("%d", &n);
	for (i = 0; i < n; i++) {
		scanf("%d %d %d %c", &nodeID, &nodeLeft, &nodeRight, &nodeData);

		if (i == 0) {
			Node* leftchild = getNode(nodeLeft);
			Node* rightchild = getNode(nodeRight);

			tree->id = nodeID;
			tree->data = nodeData;

			if (nodeLeft != 0) root->left = leftchild;
			else free(leftchild);
			if (nodeRight != 0) root->right = rightchild;
			else free(rightchild);
		}
		else {
			addNode(root, nodeID, nodeLeft, nodeRight, nodeData);
		}
	}

	int s, order, node_id;
	scanf("%d", &s);
	for (i = 0; i < s; i++) {
		scanf("%d %d", &order, &node_id); //'order'값 => 1: 전위순회, 2: 중위순회, 3: 후위순회
		if (searchNode(root, node_id) == NULL || order < 1 || order > 3) {
			printf("-1\n");
		}
		else {
			orderTree(root, order, node_id);
			printf("\n");
		}
	}
	return 0;
}
```
