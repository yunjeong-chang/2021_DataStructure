**1번. 스택을 이용하여 중위수식을 후위수식으로 변환하는 프로그램을 작성하시오. (배열 구현)**
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
	char stack[100];
	int top;
}Stack;

void init(Stack* s) { //스택 초기화
	s->top = -1;
}

int isEmpty(Stack* s) { //스택이 비어있는가?
	return (s->top == -1);
}

int isFull(Stack* s) { //스택이 꽉 차있는가?
	return (s->top == 100 - 1);
}

void push_stack(Stack* s, char data) { //스택의 top에 데이터 추가
	if (isFull(s)) {
		printf("Stack FULL\n");
		return;
	}

	(s->top)++;
	s->stack[s->top] = data;
}

char pop_stack(Stack* s) { //스택의 top에 있는 데이터 반환하고 스택에서 제거
	if (isEmpty(s)) {
		printf("Stack Empty\n");
		return;
	}

	(s->top)--;
	return s->stack[s->top+1];
}

char peek_stack(Stack* s) { //스택의 top에 있는 데이터 반환
	if (isEmpty(s)) {
		printf("Stack Empty\n");
		return;
	}
	return s->stack[s->top];
}

int prec(char op) {
	switch (op) {
	case '(': case ')': return 0;
	case '|': return 1;
	case '&': return 2;
	case '<': case '>': return 3;
	case '+': case '-': return 4;
	case '*': case '/': return 5;
	case '!': case '@': case '#': return 6;
	}
	return 0;
}

void postfix(char* sentence) {
	Stack *s = (Stack*)malloc(strlen(sentence)*sizeof(Stack));
	s->top = -1;

	char ch;
	char ch2;
	char pop_item;
	for (int i = 0; i < strlen(sentence); i++) {
		ch = sentence[i];

		if (i != 0)  ch2 = sentence[i - 1];

		if (i != 0 && (prec(ch) && prec(ch2))) {
			if (ch == '+') 	ch = '#';
			if (ch == '-')	ch = '@';
		}

		if (i == 0 && (ch == '+' || ch == '-')) {
			if (ch == '+') 	ch = '#';
			if (ch == '-')	ch = '@';
		}

		if (prec(ch)) {
			while (!isEmpty(s) && (prec(ch) <= prec(peek_stack(s)))) {
				pop_item = pop_stack(s);
				if (pop_item == '|' || pop_item == '&')  printf("%c%c", pop_item, pop_item);
				else if (pop_item == '#')  printf("%c", '+');
				else if (pop_item == '@')  printf("%c", '-');
				else  printf("%c", pop_item);
			}
			if (ch == '|' || ch == '&') {
				push_stack(s, ch);
				i++;
			}
			else
				push_stack(s, ch);
		}

		if (ch == '(')  push_stack(s, ch);

		if (ch == ')') {
			pop_item = pop_stack(s);
			while (pop_item != '(') {
				if (pop_item == '|' || pop_item == '&') printf("%c%c", pop_item, pop_item);
				else if (pop_item == '#') printf("%c", '+');
				else if (pop_item == '@') printf("%c", '-');
				else  printf("%c", pop_item);
				pop_item = pop_stack(s);
			}
		}
		if (ch >= 'A' && ch <= 'Z')  printf("%c", ch);
	}

	while (!isEmpty(s)) {
		pop_item = pop_stack(s);
		if (pop_item == '|' || pop_item == '&')  printf("%c%c", pop_item, pop_item);
		else if (pop_item == '#')  printf("%c", '+');
		else if (pop_item == '@')  printf("%c", '-');
		else  printf("%c", pop_item);
	}
}

int main() {

	int N;
	scanf("%d", &N);
	for (int i = 0; i < N; i++) {
		char* sentence = (char*)malloc(100 * sizeof(char));
		scanf("%s", sentence);
		int top = 0;
		postfix(sentence); //후위 수식으로 전환해서 출력해주는 함수
		printf("\n");
		free(sentence);
	}
	return 0;	
}

```

---

**2번. 후위로 변환된 수식을 입력받아 스택을 사용하여 계산한 후 결과 값을 출력하는 프로그램을 작성하시오 (배열 구현)**
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
	char stack[100];
	int top;
}Stack;

void init(Stack* s) { //스택 초기화
	s->top = -1;
}

int isEmpty(Stack* s) { //스택이 비어있는가?
	return (s->top == -1);
}

int isFull(Stack* s) { //스택이 꽉 차있는가?
	return (s->top == 100 - 1);
}

void push_stack(Stack* s, char data) { //스택의 top에 데이터 추가
	if (isFull(s)) {
		printf("Stack FULL\n");
		return;
	}

	(s->top)++;
	s->stack[s->top] = data;
}

char pop_stack(Stack* s) { //스택의 top에 있는 데이터 반환하고 스택에서 제거
	if (isEmpty(s)) {
		printf("Stack Empty\n");
		return;
	}

	(s->top)--;
	return s->stack[s->top+1];
}

char peek_stack(Stack* s) { //스택의 top에 있는 데이터 반환
	if (isEmpty(s)) {
		printf("Stack Empty\n");
		return;
	}
	return s->stack[s->top];
}

int prec(char op) {
	switch (op) {
	case '(': case ')': return 0;
	case '|': return 1;
	case '&': return 2;
	case '<': case '>': return 3;
	case '+': case '-': return 4;
	case '*': case '/': return 5;
	case '!': case '@': case '#': return 6;
	}
	return 0;
}

void postfix_Calculation(char* sentence) {
	Stack* s = (Stack*)malloc(strlen(sentence) * sizeof(Stack));
	s->top = -1;

	int sum = 0, tmp1 = 0, tmp2 = 0;
	for (int i = 0; i < strlen(sentence); i++) {

		if (sentence[i] >= '0' && sentence[i] <= '9') {
			push_stack(s, sentence[i] - '0');
		}

		switch (sentence[i]) {
		case '+':
			sum = pop_stack(s) + pop_stack(s);
			push_stack(s, sum);
			break;

		case '-':
			tmp1 = pop_stack(s);
			tmp2 = pop_stack(s);
			sum = tmp2 - tmp1;
			push_stack(s, sum);
			break;
		case '*':
			sum = pop_stack(s) * pop_stack(s);
			push_stack(s, sum);
			break;
		case '/':
			tmp1 = pop_stack(s);
			tmp2 = pop_stack(s);
			sum = tmp2 / tmp1;
			push_stack(s, sum);
			break;
		default:
			break;
		}
	}
	printf("%d\n", pop_stack(s));
}

int main() {

	int N;
	scanf("%d", &N);
	for (int i = 0; i < N; i++) {
		char* sentence = (char*)malloc(100 * sizeof(char));
		scanf("%s", sentence);
		int top = 0;
		postfix_Calculation(sentence); //후위 수식으로 전환해서 계산 후 값 출력해주는 함수
		free(sentence);
	}
	return 0;	
}
```

---

**1번. 스택을 이용하여 중위수식을 후위수식으로 변환하는 프로그램을 작성하시오. (연결리스트 구현)**
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
	struct node* next;
	char data;
}Node;

Node* getNode() {
	Node* new = (Node*)malloc(sizeof(Node));
	new->next = NULL;
	new->data = '\0';
	return new;
}

int isEmty(int size) {
	if (size == 0)
		return 1;
	return 0;
}

Node* PUSH(Node* head, char c, int* cnt) {
	Node* newNode = getNode();
	Node* tmp = head->next;
	newNode->data = c;
	head->next = newNode;
	newNode->next = tmp;
	(*cnt)++;
	return newNode;
}

char POP(Node* head, int* cnt) {
	if (isEmty(*cnt)) {
		printf("Stack Empty\n");
		return 0;
	}
	char tmp = head->next->data;
	Node* f = head->next;
	head->next = head->next->next;
	(*cnt)--;
	free(f);
	return tmp;
}

char PEEK(Node* head, int* cnt) {
	if (isEmty(*cnt)) {
		printf("Stack Empty\n");
		return 0;
	}
	return head->next->data;
}

int prec(char op) {
	switch (op) {
	case '|': return 1;
	case '&': return 2;
	case '<': case '>': return 3;
	case '+': case '-': return 4;
	case '*': case '/': return 5;
	case '!': case '@': case '#': return 6;
	}
	return 0;
}

void postfix(char str[]) {
	int i, cnt = 0;
	char ch, ch2, tmp;
	Node* head = getNode();

	for (i = 0; i < strlen(str); i++) {
		ch = str[i];

		if (i != 0)  ch2 = str[i - 1];

		if (i != 0 && (prec(ch) && prec(ch2))) {
			if (ch == '+') 	ch = '#';
			if (ch == '-')	ch = '@';
		}

		if (i == 0 && (ch == '+' || ch == '-')) {
			if (ch == '+') 	ch = '#';
			if (ch == '-')	ch = '@';
		}

		if (prec(ch)) {
			while (!isEmty(cnt) && (prec(ch) <= prec(PEEK(head, &cnt)))) {
				tmp = POP(head, &cnt);
				if (tmp == '|' || tmp == '&')  printf("%c%c", tmp, tmp);
				else if (tmp == '#')  printf("%c", '+');
				else if (tmp == '@')  printf("%c", '-');
				else  printf("%c", tmp);
			}
			if (ch == '|' || ch == '&') {
				PUSH(head, ch, &cnt);
				i++;
			}
			else  
				PUSH(head, ch, &cnt);
		}

		if (ch == '(')  PUSH(head, ch, &cnt);

		if (ch == ')') {
			tmp = POP(head, &cnt);
			while (tmp != '(') {
				if (tmp == '|' || tmp == '&') printf("%c%c", tmp, tmp);
				else if (tmp == '#') printf("%c", '+');
				else if (tmp == '@') printf("%c", '-');
				else  printf("%c", tmp);
				tmp = POP(head, &cnt);
			}
		}
		if (ch >= 'A' && ch <= 'Z')  printf("%c", ch);
	}

	while (!isEmty(cnt)) {
		tmp = POP(head, &cnt);
		if (tmp == '|' || tmp == '&')  printf("%c%c", tmp, tmp);
		else if (tmp == '#')  printf("%c", '+');
		else if (tmp == '@')  printf("%c", '-');
		else  printf("%c", tmp);
	}
}
int main() {
	int n, i;
	char str[100];
	scanf("%d", &n);
	for (i = 0; i < n; i++)	{
		scanf("%s", str);
		postfix(str);
		printf("\n");
	}
	return 0;
}
```

---

**2번. 후위로 변환된 수식을 입력받아 스택을 사용하여 계산한 후 결과 값을 출력하는 프로그램을 작성하시오 (연결리스트 구현)**
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
	struct node* next;
	int data;
}Node;

Node* getNode() {
	Node* new = (Node*)malloc(sizeof(Node));
	new->next = NULL;
	new->data = '\0';
	return new;
}

int isEmty(int size) {
	if (size == 0) return 1;
	return 0;
}

Node* PUSH(Node* head, int c, int* cnt) {
	Node* newNode = getNode();
	Node* temp = head->next;
	newNode->data = c;

	head->next = newNode;
	newNode->next = temp;
	(*cnt)++;
	return newNode;
}

int POP(Node* head, int* cnt) {
	if (isEmty(*cnt)) {
		printf("Stack Empty\n");
		return 0;
	}
	int tmp = head->next->data;
	Node* f = head->next;
	head->next = head->next->next;
	(*cnt)--;
	free(f);
	return tmp;
}

int PEEK(Node* head, int* cnt) {
	if (isEmty(*cnt)) {
		printf("Stack Empty\n");
		return 0;
	}

	return head->next->data;
}

int main() {
	int n, i, j, len, sum, cnt = 0, tmp[2];
	char str[100];
	Node* head = getNode();

	scanf("%d", &n);

	for (i = 0; i < n; i++) {
		scanf("%s", str);

		for (j = 0; j < strlen(str); j++) {
			if (str[j] >= '0' && str[j] <= '9') {
				PUSH(head, str[j] - '0', &cnt);
			}

			switch (str[j]) {
			case '+':
				sum = POP(head, &cnt) + POP(head, &cnt);
				PUSH(head, sum, &cnt);
				break;

			case '-':
				tmp[0] = POP(head, &cnt);
				tmp[1] = POP(head, &cnt);
				sum = tmp[1] - tmp[0];
				PUSH(head, sum, &cnt);
				break;
			case '*':
				sum = POP(head, &cnt) * POP(head, &cnt);
				PUSH(head, sum, &cnt);
				break;
			case '/':
				tmp[0] = POP(head, &cnt);
				tmp[1] = POP(head, &cnt);
				sum = tmp[1] / tmp[0];
				PUSH(head, sum, &cnt);
				break;
			default:
				break;
			}
		}
		printf("%d\n", POP(head, &cnt));
	}
	return 0;
}
```
