**1번**

![image](https://user-images.githubusercontent.com/70889699/121977496-22227d80-cdc1-11eb-9914-d1d66f6ec68a.png)


```c
#include <stdio.h>
#include <stdlib.h> //malloc, free 등 함수가 선언된 헤더파일

typedef struct node {  //이중연결리스트의 각 노드는
    char elem; //원소 및
    struct node* prev; //이전 노드를 가리키는 링크와
    struct node* next; //다음 노드를 가리키는 링크를 저장한다.
}Node;

Node* getnode() { //이중연결리스트를 노드로 할당
    Node* p = (Node*)malloc(sizeof(Node));
    p->elem = 0;
    p->next = p;
    p->prev = p;
    return p;
}

void initialize(Node* header, Node* trailer) { //이중연결리스트로 초기화
    header->next = trailer;
    trailer->prev = header;
}

int get_length(Node* header) { //이중연결리스트의 길이 측정
    Node* p;
    int size = 0;
    for (p = (header->next); (p->next) != p; p = (p->next))
        size++;
    return size;
}

void add_element(Node* header, int r, char e) { //이중연결리스트의 r번째에 e추가
    Node* p = header;
    Node* NewNode = getnode();
    for (int i = 0; i < r; i++)
        p = p->next;
    if (r < 1 || r > get_length(header) + 1) {
        printf("invalid position\n");
        return;
    }
    NewNode->elem = e;
    NewNode->next = p;
    NewNode->prev = p->prev;
    p->prev->next = NewNode;
    p->prev = NewNode;
}

void delete_element(Node* header, int r) { //이중연결리스트에서 r번째 삭제
    Node* p = header;
    for (int i = 0; i < r; i++)
        p = p->next;
    if (r < 1 || r > get_length(header)) {
        printf("invalid position\n");
        return;
    }
    p->prev->next = p->next;
    p->next->prev = p->prev;
}

char get_element(Node* header, int r) { //이중연결리스트의 r번째 원소 반환
    Node* p = header->next;
    for (int i = 1; i < r; i++)
        p = p->next;
    if (r < 1 || r > get_length(header)) {
        printf("invalid position\n");
        return -1;
    }
    return p->elem;
}
Node* search(Node* header, int index) {
    int count = 1;
    Node* target = header->next;
    while (count != index) {
        target = target->next;
        count++;
    }
    return target;
}

void swap_rank(Node* header, int r1, int r2) {
    Node* node1 = search(header, r1);
    Node* node2 = search(header, r2);
    if (r1 < 1 || r2 < 1 || r1 > get_length(header) || r2 > get_length(header)) {
        printf("invalid position\n");
        return ;
    }

    int temp = node1->elem;
    node1->elem = node2->elem;
    node2->elem = temp;
}

void print_list(Node* header) { //이중연결리스트 원소 출력
    Node* p;
    if (header->next->elem == 0) {
        printf("invalid position\n");
        return;
    }
    for (p = header->next; p->elem != 0; p = p->next) {
        printf("%c", p->elem);
    }
}

void removeAll(Node* header, Node* trailer) { //이중연결리스트 메모리 해제
    Node* p, * tmp;
    for (p = header; p->next != trailer;) {
        tmp = p->next;
        free(p);
        p = tmp;
    }
    free(trailer);
}

int main() {
    int n, rank, r1, r2;
    char check, element, returnelem;
    Node* header, * trailer;

    header = getnode();
    trailer = getnode();
    initialize(header, trailer);

    scanf("%d", &n); //연산의 개수 입력
    getchar();

    while (n != 0) {
        scanf("%c", &check); //연산의 종류 입력(A, D, G, P 中 하나)

        if (check == 'A') { //원소 추가
            scanf("%d %c", &rank, &element); 
            add_element(header, rank, element); 
        }

        else if (check == 'D') { //원소 삭제
            scanf("%d", &rank); 
            delete_element(header, rank); 
        }

        else if (check == 'G') { //원소 반환
            scanf("%d", &rank); 
            returnelem = get_element(header, rank); 
            if (returnelem != -1)
                printf("%c\n", returnelem);
        }

        else if (check == 'P') { //모든 원소 출력
            print_list(header);
            printf("\n");
        }

        else if (check == 'R') { //모든 노드 삭제
            removeAll(header, trailer);
            header = getnode();
            trailer = getnode();
            initialize(header, trailer);
        }

        else if (check == 'C') { //노드 개수 출력
            printf("%d\n", get_length(header));
        }

        else if (check == 'S') { //노드 순위 교환
            scanf("%d %d", &r1, &r2);
            swap_rank(header, r1, r2);
        }

        else {
            printf("invalid command\n");
            break;
        }

        getchar();
        n--;
    }

    return 0;
}

```
