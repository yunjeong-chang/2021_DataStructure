1번 - 이중연결리스트 이용하여 영문자 리스트 ADT 구현
```c
#include <stdio.h>
#include <stdlib.h> //malloc, free 등 함수가 선언된 헤더파일

typedef struct node {  //이중연결리스트의 각 노드는
    char elem; //원소 및
    struct node* prev; //이전 노드를 가리키는 링크와
    struct node* next; //다음 노드를 가리키는 링크를 저장한다.
}Node;

Node* getnode() { //이중연결리스트를 노드로 할당
    Node* p = (Node*)malloc(sizeof(Node));
    p->elem = 0;
    p->next = p;
    p->prev = p;
    return p;
}

void init(Node* header, Node* trailer) { //이중연결리스트로 초기화
    header->next = trailer;
    trailer->prev = header;
}

int getlen(Node* header) { //이중연결리스트의 길이 측정
    Node* p;
    int size = 0;
    for (p = (header->next); (p->next) != p; p = (p->next))
        size++;
    return size;
}

void add(Node* header, int r, char e) { //이중연결리스트의 r번째에 e추가
    Node* p = header;
    Node* NewNode = getnode();
    for (int i = 0; i < r; i++)
        p = p->next;
    if (r < 1 || r > getlen(header) + 1) {
        printf("invalid position\n");
        return;
    }
    NewNode->elem = e;
    NewNode->next = p;
    NewNode->prev = p->prev;
    p->prev->next = NewNode;
    p->prev = NewNode;
}

void deleteElement(Node* header, int r) { //이중연결리스트에서 r번째 삭제
    Node* p = header;
    for (int i = 0; i < r; i++)
        p = p->next;
    if (r < 1 || r > getlen(header)) {
        printf("invalid position\n");
        return;
    }
    p->prev->next = p->next;
    p->next->prev = p->prev;
}

char get(Node* header, int r) { //이중연결리스트의 r번째 원소 반환
    Node* p = header->next;
    for (int i = 1; i < r; i++)
        p = p->next;
    if (r < 1 || r > getlen(header)) {
        printf("invalid position\n");
        return -1;
    }
    return p->elem;
}

void print(Node* header) { //이중연결리스트 원소 출력
    Node* p;
    if (header->next->elem == 0) {
        printf("invalid position\n");
        return;
    }
    for (p = header->next; p->elem != 0; p = p->next) {
        printf("%c", p->elem);
    }
}

void freeNode(Node* header, Node* trailer) { //이중연결리스트 메모리 해제
    Node* p, * tmp;
    for (p = header; p->next != trailer;) {
        tmp = p->next;
        free(p);
        p = tmp;
    }
    free(trailer);
}

int main() {
    int n, rank;
    char check, element, returnelem;
    Node* header, * trailer;

    header = getnode();
    trailer = getnode();
    init(header, trailer);

    scanf("%d", &n); //연산의 개수 입력
    getchar();

    while (n != 0) {
        scanf("%c", &check); //연산의 종류 입력(A, D, G, P 中 하나)

        if (check == 'A') {
            scanf("%d %c", &rank, &element); //순위와 원소 입력
            add(header, rank, element); //원소 추가
        }

        else if (check == 'D') {
            scanf("%d", &rank); //순위 입력
            deleteElement(header, rank); //원소 삭제
        }

        else if (check == 'G') {
            scanf("%d", &rank); //순위 입력
            returnelem = get(header, rank); //원소 반환
            if (returnelem != -1)
                printf("%c\n", returnelem);
        }

        else if (check == 'P') {
            print(header);
            printf("\n");
        }

        else {
            printf("invalid command\n");
            break;
        }

        getchar();
        n--;
    }
    freeNode(header, trailer); //메모리 해제
    return 0;
}
```
