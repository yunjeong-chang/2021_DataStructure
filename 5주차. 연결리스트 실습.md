1번 - 이중연결리스트 이용하여 영문자 리스트 ADT 구현
```c
#include <stdio.h>
#include <stdlib.h> //malloc, free 등 함수가 선언된 헤더파일

typedef struct node {  //이중연결리스트의 각 노드는
    char elem; //원소 및
    struct node* prev; //이전 노드를 가리키는 링크와
    struct node* next; //다음 노드를 가리키는 링크를 저장한다.
}Node;

Node* getnode() { //이중연결리스트를 노드로 할당
    Node* p = (Node*)malloc(sizeof(Node));
    p->elem = 0;
    p->next = p;
    p->prev = p;
    return p;
}

void initialize(Node* header, Node* trailer) { //이중연결리스트로 초기화
    header->next = trailer;
    trailer->prev = header;
}

int get_length(Node* header) { //이중연결리스트의 길이 측정
    Node* p;
    int size = 0;
    for (p = (header->next); (p->next) != p; p = (p->next))
        size++;
    return size;
}

void add_element(Node* header, int r, char e) { //이중연결리스트의 r번째에 e추가
    Node* p = header;
    Node* NewNode = getnode();
    for (int i = 0; i < r; i++)
        p = p->next;
    if (r < 1 || r > get_length(header) + 1) {
        printf("invalid position\n");
        return;
    }
    NewNode->elem = e;
    NewNode->next = p;
    NewNode->prev = p->prev;
    p->prev->next = NewNode;
    p->prev = NewNode;
}

void delete_element(Node* header, int r) { //이중연결리스트에서 r번째 삭제
    Node* p = header;
    for (int i = 0; i < r; i++)
        p = p->next;
    if (r < 1 || r > get_length(header)) {
        printf("invalid position\n");
        return;
    }
    p->prev->next = p->next;
    p->next->prev = p->prev;
}

char get_element(Node* header, int r) { //이중연결리스트의 r번째 원소 반환
    Node* p = header->next;
    for (int i = 1; i < r; i++)
        p = p->next;
    if (r < 1 || r > get_length(header)) {
        printf("invalid position\n");
        return -1;
    }
    return p->elem;
}

void print_list(Node* header) { //이중연결리스트 원소 출력
    Node* p;
    if (header->next->elem == 0) {
        printf("invalid position\n");
        return;
    }
    for (p = header->next; p->elem != 0; p = p->next) {
        printf("%c", p->elem);
    }
}

int main() {
    int n, rank, r1, r2;
    char check, element, returnelem;
    Node* header, * trailer;

    header = getnode();
    trailer = getnode();
    initialize(header, trailer);

    scanf("%d", &n); //연산의 개수 입력
    getchar();

    while (n != 0) {
        scanf("%c", &check); //연산의 종류 입력(A, D, G, P 中 하나)

        if (check == 'A') { //원소 추가
            scanf("%d %c", &rank, &element);
            add_element(header, rank, element);
        }

        else if (check == 'D') { //원소 삭제
            scanf("%d", &rank);
            delete_element(header, rank);
        }

        else if (check == 'G') { //원소 반환
            scanf("%d", &rank);
            returnelem = get_element(header, rank);
            if (returnelem != -1)
                printf("%c\n", returnelem);
        }

        else if (check == 'P') { //모든 원소 출력
            print_list(header);
            printf("\n");
        }

        else {
            printf("invalid command\n");
            break;
        }

        getchar();
        n--;
    }

    return 0;
}
```
